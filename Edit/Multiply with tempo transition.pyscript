"""flp
Title: Multiply with tempo transition
Author: BinaryBorn
Category: Edit
Version: 1.5
License: ISC

Description: 
Repeats notes with a tempo transition from one rate to another.

Changelog:
v1.0 (2023-07-11)
  - initial version

v1.1 (2023-07-17)
  - replaced tension function
  - added note.release

v1.2 (2023-10-16)
  - added ISC license text

v1.3 (2023-10-20)
  - added getTimelineSelection()
  - replaced cloning function
  - fixed behavior when notes with different length are selected

v1.4 (2024-03-08)
  - FIXED typings for Python engine upgrade

v1.5 (2024-06-06)
  - ADDED delta length sweep mode
  - ADDED sweep tension
  - CHANGED calculation is now discrete instead of algebraically correct
  - ADDED marker option
"""

import flpianoroll as flp
import math

def getTimeRange(notes: list[flp.Note]) -> tuple[int, int]:
  """Returns start and end time of list of notes.
  """
  if len(notes) == 0: return (0, 0)
  # find first starting and last ending note
  first = min(notes, key=lambda n: n.time)
  last = max(notes, key=lambda n: n.time + n.length)
  # return start and end time
  return (first.time, last.time + last.length)

def Tension(value: float, rate: float, knob=True):
  """Applies the FL Studio Tension function to a value.

  Args:
    value (float): value to skew
    rate (float): tension rate
    knob (bool): if True, function behaves like the one behind knobs (e.g. scale levels), if False, it behaves like the one in Formula Controller
  """
  if rate == 0: return value
  # rate mapping
  R = rate
  if not knob and rate > 0:
    R = math.log2(rate + 1) / 10
  elif not knob and rate < 0:
    R = -math.log2(-rate + 1) / 10
  # f(x,R) = (2^(-10*R*x)-1)/(2^(-10*R)-1)
  return (pow(2, -10 * R * value) - 1) / (pow(2, -10 * R) - 1)

# check for timeline selection
selection = flp.score.getTimelineSelection()

def createDialog():
  form = flp.ScriptDialog("Multiply with tempo transition","Start and end rate multiply the sequences's tempo."
  + "\r\nDuration is in beats."
  + "\r\nPhase correction is only relevant when the transition doesn't fit the transition duration exactly, the transition will then include a whole number multiple of the sequence. Phase correction tension defines how immediate the correction is applied - higher values will correct faster."
  + "\r\n\r\nv1.5 (2024-06-06), BinaryBorn")
  form.AddInputKnob('Start rate', 1, 1/16, 16)
  form.AddInputKnob('End rate', 2, 1/16, 16)
  form.AddInputKnobInt('Copies before', 0, 0, 16)
  form.AddInputKnobInt('Copies after', 0, 0, 16)
  form.AddInputKnobInt('Duration', 8, 1, 32 * 16)
  form.AddInputCombo('Sweep', ['note frequency', 'note length'], 0)
  form.AddInputKnob('Tension', 0, -1, 1)
  form.AddInputCombo('Phase correction', ['none', 'stretch', 'squash'], 0)
  form.AddInputKnob('Ph. corr. tension', 0, -1, 1)
  form.AddInputCheckbox('Markers', True)
  
  return form

def apply(form: flp.ScriptDialog):
  pulses: list[float] = []
  ppq = flp.score.PPQ

  # get current notes
  notesCnt = flp.score.noteCount
  notes = [flp.score.getNote(i) for i in range(notesCnt)]

  if not notes: return

  # try using timeline selection
  selection = flp.score.getTimelineSelection()
  # ... fall back to notes' range when no timeline selection was made
  if (selection[1] == -1): selection = getTimeRange(notes)
  selt0 = selection[0]
  selt1 = selection[1]
  seldt = selt1 - selt0

  # pulses per copy (the more, the finer the interpolation)
  ppc = round(seldt / ppq * 4)
  # notes per copy
  npc = notesCnt

  # scale to rate (1 per tick)
  r0 = 4 / ppq * float(form.GetInputValue('Start rate'))
  r1 = 4 / ppq * float(form.GetInputValue('End rate'))
  # duration in ticks
  dt = int(form.GetInputValue('Duration')) * ppq

  c0 = int(form.GetInputValue('Copies before'))
  c1 = int(form.GetInputValue('Copies after'))

  mode = int(form.GetInputValue('Sweep'))
  tension = float(form.GetInputValue('Tension'))

  corr = int(form.GetInputValue('Phase correction'))
  corrTension = float(form.GetInputValue('Ph. corr. Tension'))

  optMarkers = int(form.GetInputValue('Markers'))

  p0 = c0 * ppc
  p1 = c1 * ppc

  # pulse lengths
  L0 = 1 / r0
  L1 = 1 / r1

  # before transition
  for p in range(p0):
    t0 = round(p / r0)
    pulses.append(t0)

  # transition
  toff0 = round(p0 / r0)

  tpulses: list[int] = []
  dp = 0
  p_next = 0
  for t in range(dt + 1): # dt must be included here (for spot-on-phase transitions, otherwise they'd be stretched/squashed)
    t_star = t / dt
    if mode == 0:
      dp += (r1 - r0) * Tension(t_star, tension) + r0
    else:
      dp += 1 / ((L1 - L0) * Tension(t_star, tension) + L0)
    if dp >= p_next:
      tpulses.append(t)
      p_next += 1

  ttrans = tpulses[-1]
  corrRequired = ttrans != dt or len(tpulses) % ppc != 1

  # if phase correction is set to squash and required, find one additional pulse
  if corr == 2 and corrRequired:
    t = dt
    while True:
      t += 1
      dp += r1
      if dp >= p_next:
        tpulses.append(t)
        p_next += 1
        if len(tpulses) % ppc == 1:
          break
    ttrans = tpulses[-1]
  # if phase correction is set to stretch and required, drop incomplete set of pulses
  elif corr == 1 and corrRequired:
    while len(tpulses) % ppc != 1:
      del tpulses[-1]
      dp -= 1
    ttrans = tpulses[-1]

  dp = math.floor(dp)

  # no phase correction required
  if corr == 0 or not corrRequired:
    ttransEff = ttrans
  # apply phase correction
  else:
    ttransEff = dt
    for p in range(dp + 1):
      t = tpulses[p]
      s = ttransEff / ttrans
      sf0 = Tension(t / ttrans, corrTension)
      t = t * (1 + sf0 * (s - 1))
      tpulses[p] = round(t)

  # drop the last pulse - will be appended later on
  del tpulses[-1]

  pulses.extend([t + toff0 for t in tpulses])

  # after transition
  toff1 = toff0 + ttransEff
  for p in range(p1):
    t0 = round(p / r1)
    pulses.append(t0 + toff1)
  
  # final pulse
  tend = round(p1 / r1)
  pulses.append(tend + toff1)

  # number of pulses, copies and notes
  ptot = len(pulses)
  ctot = math.floor(ptot / ppc)
  ntot = ctot * npc

  def getPulse(i: int) -> float:
    "Returns pulse time at given index - extrapolates if index too big"
    if i < ptot:
      return pulses[i]
    return pulses[-1] + (i - ptot + 1) / r1

  def mapTime(time: int) -> int:
    "Maps in time onto the pulse grid"
    it = time / seldt * ppc
    i0 = math.floor(it)
    f = it - i0
    t0 = getPulse(i0)
    if f == 0:
      return round(t0)
    t1 = getPulse(i0 + 1)
    dt = t1 - t0
    return round(t0 + f * dt)
  
  flp.score.clearNotes()

  for i in range(ntot):
    c = math.floor(i / npc)
    coff = c * seldt
    n = notes[i % npc]
    nt0 = n.time + coff
    nt1 = nt0 + n.length
    t0 = mapTime(nt0)
    t1 = mapTime(nt1)
    note = n.clone()
    note.time = t0
    note.length = t1 - t0
    flp.score.addNote(note)

  if optMarkers:
    m0 = flp.Marker()
    m0.name = 'Transition start'
    m0.time = toff0
    flp.score.addMarker(m0)
    m1 = flp.Marker()
    m1.name = 'Transition end'
    m1.time = toff1
    flp.score.addMarker(m1)