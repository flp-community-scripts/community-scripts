"""flp
Title: Generate tempo transition
Author: BinaryBorn
Category: Generate (rhythm)
Version: 1.3
License: ISC

Description: 
Generates a transition from one rate to another.

Changelog:
v1.0 (2023-07-11)
  - initial version

v1.1 (2023-07-17)
  - replaced tension function

v1.2 (2023-09-21)
  - added ISC license text

v1.3 (2024-03-15)
  - CHANGED note properties now consider current defaults

v1.4 (2024-05-30)
  - ADDED delta length tempo change mode
  - CHANGED max frequency now depends on PPQ
  - CHANGED timeline selection now offsets generated score

v1.5 (2024-05-31)
  - ADDED sweep tension
  - CHANGED mode wording to sweep
  - CHANGED calculation is now discrete instead of algebraically correct
  - ADDED zero length notes option
"""

import flpianoroll as flp
import math

def Tension(value: float, rate: float, knob=True):
  """Applies the FL Studio Tension function to a value.

  Args:
    value (float): value to skew
    rate (float): tension rate
    knob (bool): if True, function behaves like the one behind knobs (e.g. scale levels), if False, it behaves like the one in Formula Controller
  """
  if rate == 0: return value
  # rate mapping
  R = rate
  if not knob and rate > 0:
    R = math.log2(rate + 1) / 10
  elif not knob and rate < 0:
    R = -math.log2(-rate + 1) / 10
  # f(x,R) = (2^(-10*R*x)-1)/(2^(-10*R)-1)
  return (pow(2, -10 * R * value) - 1) / (pow(2, -10 * R) - 1)

# check for timeline selection
selection = flp.score.getTimelineSelection()

def createDialog():
  form = flp.ScriptDialog("Generate tempo transition","Start and end freq are in 'pulses per whole note'."
  + "\r\nDuration is in beats."
  + "\r\nPhase correction is only relevant when the transition doesn't fit the transition duration exactly. Phase correction tension defines how immediate the correction is applied - higher values will correct faster."
  + "\r\n\r\nv1.5 (2024-05-31), BinaryBorn")

  # fmax = flp.score.PPQ * 4 # actual technical maximum
  fmax = flp.score.PPQ # feels like the better UX choice

  duration = 16
  if selection[1] != -1:
    duration = round((selection[1] - selection[0]) / flp.score.PPQ)

  form.AddInputKnobInt('Start freq', 4, 1, fmax)
  form.AddInputKnobInt('End freq', 8, 1, fmax)
  form.AddInputKnobInt('Pulses before', 0, 0, 16)
  form.AddInputKnobInt('Pulses after', 0, 0, 16)
  form.AddInputKnobInt('Duration', duration, 1, 32 * 16)
  form.AddInputCombo('Sweep', ['pulse frequency', 'pulse length'], 0)
  form.AddInputKnob('Tension', 0, -1, 1)
  form.AddInputKnobInt('Note', 60, 0, 131)
  form.AddInputCombo('Phase correction', ['none', 'stretch', 'squash'], 0)
  form.AddInputKnob('Ph. corr. tension', 0, -1, 1)
  form.AddInputCheckbox('Zero length notes', False)
  
  return form

def apply(form: flp.ScriptDialog):
  pulses: list[int] = []
  ppq = flp.score.PPQ

  offset = 0
  if selection[1] != -1:
    offset = selection[0]

  # convert freq (1 per 4 beats) to rate (1 per tick)
  r0 = int(form.GetInputValue('Start freq')) / ppq / 4
  r1 = int(form.GetInputValue('End freq')) / ppq / 4
  # duration in ticks
  dt = int(form.GetInputValue('Duration')) * ppq

  p0 = int(form.GetInputValue('Pulses before'))
  p1 = int(form.GetInputValue('Pulses after'))

  mode = int(form.GetInputValue('Sweep'))
  tension = float(form.GetInputValue('Tension'))

  corr = int(form.GetInputValue('Phase correction'))
  corrTension = float(form.GetInputValue('Ph. corr. Tension'))

  noteNr = int(form.GetInputValue('Note'))
  zeroLength = bool(form.GetInputValue('Zero length notes'))

  # pulse lengths and delta pulse length
  L0 = 1 / r0
  L1 = 1 / r1

  # before transition
  for p in range(p0):
    t0 = round(p / r0)
    pulses.append(t0)

  # transition
  toff0 = round(p0 / r0)

  tpulses: list[int] = []
  dp = 0
  p_next = 0
  for t in range(dt + 1): # dt must be included here (for spot-on-phase transitions, otherwise they'd be stretched/squashed)
    t_star = t / dt
    if mode == 0:
      dp += (r1 - r0) * Tension(t_star, tension) + r0
    else:
      dp += 1 / ((L1 - L0) * Tension(t_star, tension) + L0)
    if dp >= p_next:
      tpulses.append(t)
      p_next += 1

  ttrans = tpulses[math.floor(dp)]
  corrRequired = ttrans != dt

  # if phase correction is set to squash and required, find one additional pulse
  if corr == 2 and corrRequired:
    t = dt
    while True:
      t += 1
      dp += r1
      if dp >= p_next:
        tpulses.append(t)
        break
    ttrans = tpulses[math.floor(dp)]

  dp = math.floor(dp)

  # no phase correction required
  if corr == 0 or not corrRequired:
    ttransEff = ttrans
  # apply phase correction
  else:
    ttransEff = dt
    for p in range(dp + 1):
      t = tpulses[p]
      s = ttransEff / ttrans
      sf0 = Tension(t / ttrans, corrTension)
      t = t * (1 + sf0 * (s - 1))
      tpulses[p] = round(t)

  # drop the last pulse if it falls exactly on dt
  if tpulses[dp] == dt:
    del tpulses[-1]

  pulses.extend([t + toff0 for t in tpulses])

  # after transition
  toff1 = toff0 + ttransEff
  for p in range(p1):
    t0 = round(p / r1)
    pulses.append(t0 + toff1)
  
  # final pulse to end last one
  tend = round(p1 / r1)
  pulses.append(tend + toff1)

  for i in range(len(pulses) - 1):
    t0 = pulses[i]
    t1 = pulses[i+1]
    # only append notes that actually have space to be placed
    if t1 > t0:
      note = flp.score.getDefaultNoteProperties().clone()
      note.number = noteNr
      note.time = t0 + offset
      note.length = 0 if zeroLength else t1 - t0
      flp.score.addNote(note)
