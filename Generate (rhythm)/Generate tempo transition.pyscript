"""flp
Title: Generate tempo transition
Author: BinaryBorn
Category: Generate (rhythm)
Version: 1.3
License: ISC

Description: 
Generates a transition from one rate to another.

Changelog:
v1.0 (2023-07-11)
  - initial version

v1.1 (2023-07-17)
  - replaced tension function

v1.2 (2023-09-21)
  - added ISC license text

v1.3 (2024-03-15)
  - CHANGED note properties now consider current defaults

v1.4 (2024-05-30)
  - ADDED delta length tempo change mode
  - CHANGED max frequency now depends on PPQ
  - CHANGED timeline selection now offsets generated score
"""

import flpianoroll as flp
import math

def Tension(value: float, rate: float, knob=True):
  """Applies the FL Studio Tension function to a value.

  Args:
    value (float): value to skew
    rate (float): tension rate
    knob (bool): if True, function behaves like the one behind knobs (e.g. scale levels), if False, it behaves like the one in Formula Controller
  """
  if rate == 0: return value
  # rate mapping
  R = rate
  if not knob and rate > 0:
    R = math.log2(rate + 1) / 10
  elif not knob and rate < 0:
    R = -math.log2(-rate + 1) / 10
  # f(x,R) = (2^(-10*R*x)-1)/(2^(-10*R)-1)
  return (pow(2, -10 * R * value) - 1) / (pow(2, -10 * R) - 1)

# check for timeline selection
selection = flp.score.getTimelineSelection()

def createDialog():
  form = flp.ScriptDialog("Generate tempo transition","Start and end freq are in 'pulses per whole note'."
  + "\r\nDuration is in beats."
  + "\r\nPhase correction is only relevant when the transition doesn't fit the transition duration exactly. Phase correction tension defines how immediate the correction is applied - higher values will correct faster."
  + "\r\n\r\nv1.4 (2024-05-30), BinaryBorn")

  # fmax = flp.score.PPQ * 4 # actual technical maximum
  fmax = flp.score.PPQ # feels like the better UX choice

  duration = 16
  if selection[1] != -1:
    duration = round((selection[1] - selection[0]) / flp.score.PPQ)

  form.AddInputKnobInt('Start freq', 4, 1, fmax)
  form.AddInputKnobInt('End freq', 8, 1, fmax)
  form.AddInputKnobInt('Pulses before', 0, 0, 16)
  form.AddInputKnobInt('Pulses after', 0, 0, 16)
  form.AddInputKnobInt('Duration', duration, 1, 32 * 16)
  form.AddInputCombo('Tempo change', ['delta frequency', 'delta length'], 0)
  form.AddInputCombo('Phase correction', ['none', 'stretch', 'squash'], 0)
  form.AddInputKnob('Ph. corr. tension', 0, -1, 1)
  form.AddInputKnobInt('Note', 60, 0, 131)
  
  return form

def apply(form: flp.ScriptDialog):
  notes: list[flp.Note] = []
  ppq = flp.score.PPQ

  offset = 0
  if selection[1] != -1:
    offset = selection[0]

  # convert freq (1 per 4 beats) to rate (1 per tick)
  r0 = int(form.GetInputValue('Start freq')) / ppq / 4
  r1 = int(form.GetInputValue('End freq')) / ppq / 4
  # duration in ticks
  dt = int(form.GetInputValue('Duration')) * ppq

  p0 = int(form.GetInputValue('Pulses before'))
  p1 = int(form.GetInputValue('Pulses after'))

  mode = int(form.GetInputValue('Tempo change'))

  corr = int(form.GetInputValue('Phase correction'))
  corrTension = float(form.GetInputValue('Ph. corr. Tension'))

  noteNr = int(form.GetInputValue('Note'))

  # delta rate in transition
  dr = r1 - r0
  # rate of rate change
  R = dr / dt
  # pulse lengths and delta pulse length
  L0 = 1 / r0
  L1 = 1 / r1
  RL = (L1 - L0) / dt

  def pfromtCA(t: float) -> float:
    return r0 * t + 1/2 * R * t ** 2

  def tfrompCA(p: float) -> float:
    if R == 0:
      return p / r0
    else:
      D = max(r0 ** 2 + 2 * R * p, 0)
      return (math.sqrt(D) - r0) / R 

  def pfromtCDT(t: float) -> float:
    if RL == 0:
      return r0 * t
    else:
      return math.log((RL * t) / L0 + 1) / RL

  def tfrompCDT(p: float) -> float:
    if RL == 0:
      return p / r0
    else:
      return (math.exp(RL * p) - 1) / (RL / L0)

  pfromt = pfromtCA
  tfromp = tfrompCA
  if mode == 1:
    pfromt = pfromtCDT
    tfromp = tfrompCDT

  # before transition
  for p in range(p0):
    t0 = round(p / r0)
    t1 = round((p + 1) / r0)
    note = flp.score.getDefaultNoteProperties().clone()
    note.number = noteNr
    note.time = t0 + offset
    note.length = t1 - t0
    notes.append(note)

  # transition
  toff0 = round(p0 / r0)
  dp = pfromt(dt)

  # phase correction (and duration correction, if applicable)
  if corr == 0:
    dp = round(dp)
  elif corr == 1:
    dp = math.floor(dp)
  elif corr == 2:
    dp = math.ceil(dp)
  ttrans = round(tfromp(dp))
  if corr == 0:
    ttransEff = ttrans
  else:
    ttransEff = dt

  for p in range(dp):
    t0 = round(tfromp(p))
    t1 = round(tfromp(p+1))
    # phase correction
    if corr:
      s = ttransEff / ttrans
      sf0 = Tension(t0 / ttrans, corrTension)
      sf1 = Tension(t1 / ttrans, corrTension)
      t0 = round(t0 * (1 + sf0 * (s - 1)))
      t1 = round(t1 * (1 + sf1 * (s - 1)))
    note = flp.score.getDefaultNoteProperties().clone()
    note.number = noteNr
    note.time = t0 + toff0 + offset
    note.length = t1 - t0
    notes.append(note)

  # after transition
  toff1 = toff0 + ttransEff
  for p in range(p1):
    t0 = round(p / r1)
    t1 = round((p + 1) / r1)
    note = flp.score.getDefaultNoteProperties().clone()
    note.number = noteNr
    note.time = t0 + toff1 + offset
    note.length = t1 - t0
    notes.append(note)

  for note in notes:
    flp.score.addNote(note)
