"""flp
Title: {}
Author: BinaryBorn
Category: {}
Version: 1.0
License: ISC

Description: 
{}

Changelog:
v1.0 (2024-02-19)
  - initial version
"""

import flpianoroll as flp
import kaki
import math

# don't render back faces (pure optimisation)
kaki.config.cull_backface = False

shapes = ['Cube', 'Prism', 'Pyramid', 'Pyramid frustum', 'Sphere', 'Cylinder', 'Cone', 'Cone frustum', 'Torus']

def createDialog():
  form = flp.ScriptDialog("Draw 3D primitive","-"
  + "\r\n--"
  + "\r\n\r\nv1.0 (2024-mm-dd), BinaryBorn")

  mat = kaki.getPhenotypeFromNote(flp.score.getDefaultNoteProperties())
  styleMat = kaki.serializePhenotypeToStyle(mat)
  light = kaki.copyPhenotype(mat)
  light.vel = 1.0
  light.col = (light.col + 8) % 16
  styleLight = kaki.serializePhenotypeToStyle(light)

  form.AddInputCombo('Shape', shapes, 0)
  form.AddInputKnobInt('Sides', 3, 3, 24)
  form.AddInputKnob('Ratio', 0.5, 0, 1)
  form.AddInputKnobInt('Center x', 16, 0, 128)
  form.AddInputKnobInt('Center y', 60, 0, 131)
  form.AddInputKnobInt('Center z', 0, -128, 0)
  form.AddInputKnob('Scale x', 16, 0, 128)
  form.AddInputKnob('Scale y', 16, 0, 128)
  form.AddInputKnob('Scale z', 16, 0, 128)
  form.AddInputKnob('Rotate x', math.pi / 4, -math.pi, math.pi)
  form.AddInputKnob('Rotate y', math.pi / 6, -math.pi, math.pi)
  form.AddInputKnob('Rotate z', 0, -math.pi, math.pi)
  form.AddInputCombo('Rotation order', ['zyx', 'xyz'], 0)
  form.AddInputKnob('Pinch', 0, 0, 0.02)
  form.AddInputText('Material', styleMat)
  form.AddInputText('Light', styleLight)
  form.AddInputCombo('Oversample', ['--', '4x MSAA', '16x MSAA'], 0)
  form.AddInputKnob('Light azimuth', 0, -math.pi, math.pi)
  form.AddInputKnob('Light elevation', 0, 0, math.pi / 2)
  form.AddInputKnob('Fog near', 0, -128, 128)
  form.AddInputKnob('Fog far', -128, -128, 128)

  return form

def apply(form: flp.ScriptDialog):
  optShape = form.GetInputValue('Shape')
  sides = form.GetInputValue('Sides')
  ratio = form.GetInputValue('Ratio')
  cx = form.GetInputValue('Center x')
  cy = form.GetInputValue('Center y')
  cz = form.GetInputValue('Center z')
  sx = form.GetInputValue('Scale x')
  sy = form.GetInputValue('Scale y')
  sz = form.GetInputValue('Scale z')
  rotx = form.GetInputValue('Rotate x')
  roty = form.GetInputValue('Rotate y')
  rotz = form.GetInputValue('Rotate z')
  rotOrder = form.GetInputValue('Rotation order')
  pinch = form.GetInputValue('Pinch')
  styleMat = form.GetInputValue('Material')
  styleLight = form.GetInputValue('Light')
  optOversample = form.GetInputValue('Oversample')
  lightAzi = form.GetInputValue('Light azimuth')
  lightEle = form.GetInputValue('Light elevation')
  fog0 = form.GetInputValue('Fog near')
  fog1 = form.GetInputValue('Fog far')

  shape = shapes[optShape]
  phenoMat = kaki.parsePhenotypeFromStyle(styleMat)
  phenoLight = kaki.parsePhenotypeFromStyle(styleLight)

  mesh: kaki.mesh
  if shape == 'Cube':
    mesh = kaki.createCube(phenoMat)
  elif shape == 'Prism':
    mesh = kaki.createPrism(phenoMat, sides)
  elif shape == 'Pyramid':
    mesh = kaki.createPrism(phenoMat, sides, 0)
  elif shape == 'Pyramid frustum':
    mesh = kaki.createPrism(phenoMat, sides, ratio)
  elif shape == 'Sphere':
    mesh = kaki.createSphere(phenoMat, 24)
  elif shape == 'Cylinder':
    mesh = kaki.createCylinder(phenoMat, 24)
  elif shape == 'Cone':
    mesh = kaki.createCylinder(phenoMat, 24, 0)
  elif shape == 'Cone frustum':
    mesh = kaki.createCylinder(phenoMat, 24, ratio)
  elif shape == 'Torus':
    mesh = kaki.createTorus(phenoMat, 24, ratio)
  else:
    mesh = kaki.mesh([], [], [])

  # first: transform up to including rotation (because of lighting)
  transform3d = kaki.identity4()
  transform3d = kaki.scale(transform3d, sx, sy, sz)
  if rotOrder == 0:
    transform3d = kaki.rotateZ(transform3d, rotz)
    transform3d = kaki.rotateY(transform3d, roty)
    transform3d = kaki.rotateX(transform3d, rotx)
  else:
    transform3d = kaki.rotateX(transform3d, rotx)
    transform3d = kaki.rotateY(transform3d, roty)
    transform3d = kaki.rotateZ(transform3d, rotz)
  kaki.transformMesh(mesh, transform3d)

  # second: lighting (before pinching)
  kaki.updateNormalsMesh(mesh)
  light = kaki.vec4(1, 0, 0)
  trLight = kaki.identity4()
  trLight = kaki.rotateY(trLight, lightEle)
  trLight = kaki.rotateZ(trLight, lightAzi)
  light = kaki.transform(light, trLight)
  kaki.lightMesh(mesh, light, phenoLight)

  # third: move into shot, pinch, move shot
  transform3d = kaki.identity4()
  transform3d = kaki.translate(transform3d, 0, 0, cz)
  transform3d = kaki.perspectiveTransform(transform3d, pinch)
  transform3d = kaki.translate(transform3d, cx, cy, 0)
  kaki.transformMesh(mesh, transform3d)
  kaki.perspectiveDivideMesh(mesh)

  bbox = kaki.getMeshBoundingBox(mesh, True)
  if bbox is None: return

  # limit bbox to PR and some sensible value for max x
  kaki.limitBox(bbox, kaki.box(0, 0, 1024, 131))

  buffer = kaki.Buffer(bbox.x1 - bbox.x0, bbox.y1 - bbox.y0, optOversample, True)
  buffer.setOrigin(bbox.x0, bbox.y0)

  kaki.drawMesh(buffer, mesh)

  buffer.fog(fog0, fog1)

  newNotes = kaki.render(buffer, bbox.x0, bbox.y0)

  for n in newNotes:
    n.group = 1
    flp.score.addNote(n)