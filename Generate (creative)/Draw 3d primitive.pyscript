"""flp
Title: {}
Author: BinaryBorn
Category: {}
Version: 1.0
License: ISC

Description: 
{}

Changelog:
v1.0 (2024-02-19)
  - initial version
"""

import flpianoroll as flp
import kaki
import math

# don't render back faces (pure optimisation)
kaki.config.cull_backface = False

# TODO: cylinder, torus
shapes = ['Cube', 'Prism', 'Sphere']

def createCube(pheno: kaki.phenotype) -> kaki.mesh:
  verts: list[kaki.vec4] = []
  phenos: list[kaki.phenotype] = []
  tris: list[kaki.tri] = []
  for i in range(6):
    vs = [
      kaki.vec4(0.5, 0.5, 0.5),
      kaki.vec4(-0.5, 0.5, 0.5),
      kaki.vec4(-0.5, -0.5, 0.5),
      kaki.vec4(0.5, -0.5, 0.5)
    ]
    tr = kaki.identity4()
    if i < 4:
      tr = kaki.rotateX(tr, i * math.pi / 2)
    elif i == 4:
      tr = kaki.rotateY(tr, -math.pi / 2)
    elif i == 5:
      tr = kaki.rotateY(tr, math.pi / 2)
    kaki.transformPoints(vs, tr)
    verts.extend(vs)
    phenos.extend([kaki.copyPhenotype(pheno)] * 4)
    i0 = i * 4
    tris.extend([
      [i0 + 0, i0 + 1, i0 + 2],
      [i0 + 0, i0 + 2, i0 + 3],
    ])
  return kaki.mesh(verts, phenos, tris)

def createPrism(pheno: kaki.phenotype, sides: int) -> kaki.mesh:
  if sides < 3: sides = 3
  if sides > 24: sides = 24

  verts: list[kaki.vec4] = []
  phenos: list[kaki.phenotype] = []
  tris: list[kaki.tri] = []

  for i in range(sides):
    a0 = i * 2 * math.pi / sides
    a1 = (i + 1) * 2 * math.pi / sides
    v0 = kaki.vec4(math.cos(a0), 0, math.sin(a0))
    v1 = kaki.vec4(math.cos(a1), 0, math.sin(a1))
    i0 = i * 10
    vs = [
      kaki.vec4(v0.x, 0.5, v0.z),
      kaki.vec4(v1.x, 0.5, v1.z),
      kaki.vec4(v1.x, -0.5, v1.z),
      kaki.vec4(v0.x, -0.5, v0.z),
      kaki.vec4(0, 0.5, 0),
      kaki.vec4(v0.x, 0.5, v0.z),
      kaki.vec4(v1.x, 0.5, v1.z),
      kaki.vec4(0, -0.5, 0),
      kaki.vec4(v1.x, -0.5, v1.z),
      kaki.vec4(v0.x, -0.5, v0.z),
    ]
    ps = [kaki.copyPhenotype(pheno)] * 10
    ts = [
      [0, 1, 2],
      [0, 2, 3],
      [4, 6, 5],
      [7, 9, 8],
    ]
    ts = [[i+i0 for i in t] for t in ts]
    
    verts.extend(vs)
    phenos.extend(ps)
    tris.extend(ts)
  return kaki.mesh(verts, phenos, tris)

def createSphere(pheno: kaki.phenotype) -> kaki.mesh:
  verts: list[kaki.vec4] = []
  tris: list[kaki.tri] = []

  I = 24
  J = 11 # I / 2 - 1
  IJ = I * J
  for i in range(I):
    vs = []
    ts = []
    for j in range(J):
      a = math.pi / 2 - (j + 1) * math.pi / (J + 1)
      v = kaki.vec4(math.cos(a), math.sin(a), 0)
      vs.append(v)
      if (j < J - 1):
        i0 = i * J + j
        ts.extend([
          [i0 + 0, (i0 + J) % IJ, (i0 + J + 1) % IJ],
          [i0 + 0, (i0 + J + 1) % IJ, (i0 + 1) % IJ],
        ])
    tr = kaki.identity4()
    tr = kaki.rotateY(tr, -i * 2 * math.pi / I)
    kaki.transformPoints(vs, tr)
    verts.extend(vs)
    tris.extend(ts)
  verts.append(kaki.vec4(0, 1, 0))
  verts.append(kaki.vec4(0, -1, 0))
  for i in range(I):
    i0 = i * J
    tris.append([IJ, (i0 + J) % IJ, i0])
    i0 = (i + 1) * J - 1
    tris.append([IJ + 1, i0, (i0 + J) % IJ])

  phenos = [kaki.copyPhenotype(pheno)] * len(verts)
  
  return kaki.mesh(verts, phenos, tris)

def createDialog():
  form = flp.ScriptDialog("Draw 3D primitive","-"
  + "\r\n--"
  + "\r\n\r\nv1.0 (2024-mm-dd), BinaryBorn")
  form.AddInputCombo('Shape', shapes, 0)
  form.AddInputKnobInt('Sides', 3, 3, 24)
  form.AddInputKnobInt('Center x', 16, 0, 128)
  form.AddInputKnobInt('Center y', 60, 0, 131)
  form.AddInputKnobInt('Center z', 0, -128, 0)
  form.AddInputKnob('Scale x', 16, 0, 128)
  form.AddInputKnob('Scale y', 16, 0, 128)
  form.AddInputKnob('Scale z', 16, 0, 128)
  form.AddInputKnob('Rotate x', 0, -math.pi, math.pi)
  form.AddInputKnob('Rotate y', 0, -math.pi, math.pi)
  form.AddInputKnob('Rotate z', 0, -math.pi, math.pi)
  form.AddInputCombo('Rotation order', ['zyx', 'xyz'], 0)
  form.AddInputKnob('Pinch', 0, 0, 0.02)
  form.AddInputText('Material', 'velocity: 0.5; pan: 0.0; color: 0')
  form.AddInputText('Light', 'velocity: 1; pan: 0.0; color: 8')
  form.AddInputCombo('Oversample', ['--', '4x MSAA', '16x MSAA'], 0)
  form.AddInputKnob('Light azimuth', 0, -math.pi, math.pi)
  form.AddInputKnob('Light elevation', 0, 0, math.pi / 2)
  form.AddInputKnob('Fog near', 0, -128, 128)
  form.AddInputKnob('Fog far', -128, -128, 128)

  return form

def apply(form: flp.ScriptDialog):
  optShape = form.GetInputValue('Shape')
  sides = form.GetInputValue('Sides')
  cx = form.GetInputValue('Center x')
  cy = form.GetInputValue('Center y')
  cz = form.GetInputValue('Center z')
  sx = form.GetInputValue('Scale x')
  sy = form.GetInputValue('Scale y')
  sz = form.GetInputValue('Scale z')
  rotx = form.GetInputValue('Rotate x')
  roty = form.GetInputValue('Rotate y')
  rotz = form.GetInputValue('Rotate z')
  rotOrder = form.GetInputValue('Rotation order')
  pinch = form.GetInputValue('Pinch')
  styleMat = form.GetInputValue('Material')
  styleLight = form.GetInputValue('Light')
  optOversample = form.GetInputValue('Oversample')
  lightAzi = form.GetInputValue('Light azimuth')
  lightEle = form.GetInputValue('Light elevation')
  fog0 = form.GetInputValue('Fog near')
  fog1 = form.GetInputValue('Fog far')

  shape = shapes[optShape]
  phenoMat = kaki.parsePhenotypeFromStyle(styleMat)
  phenoLight = kaki.parsePhenotypeFromStyle(styleLight)

  mesh: kaki.mesh
  if shape == 'Cube':
    mesh = createCube(phenoMat)
  elif shape == 'Prism':
    mesh = createPrism(phenoMat, sides)
  elif shape == 'Sphere':
    mesh = createSphere(phenoMat)

  # first: transform up to including rotation (because of lighting)
  transform3d = kaki.identity4()
  transform3d = kaki.scale(transform3d, sx, sy, sz)
  if rotOrder == 0:
    transform3d = kaki.rotateZ(transform3d, rotz)
    transform3d = kaki.rotateY(transform3d, roty)
    transform3d = kaki.rotateX(transform3d, rotx)
  else:
    transform3d = kaki.rotateX(transform3d, rotx)
    transform3d = kaki.rotateY(transform3d, roty)
    transform3d = kaki.rotateZ(transform3d, rotz)
  kaki.transformMesh(mesh, transform3d)

  # second: lighting (before pinching)
  kaki.updateNormalsMesh(mesh)
  light = kaki.vec4(1, 0, 0)
  trLight = kaki.identity4()
  trLight = kaki.rotateY(trLight, lightEle)
  trLight = kaki.rotateZ(trLight, lightAzi)
  light = kaki.transform(light, trLight)
  kaki.lightMesh(mesh, light, phenoLight)

  # third: move into shot, pinch, move shot
  transform3d = kaki.identity4()
  transform3d = kaki.translate(transform3d, 0, 0, cz)
  transform3d = kaki.perspectiveTransform(transform3d, pinch)
  transform3d = kaki.translate(transform3d, cx, cy, 0)
  kaki.transformMesh(mesh, transform3d)
  kaki.perspectiveDivideMesh(mesh)

  bbox = kaki.getMeshBoundingBox(mesh, True)
  if bbox is None: return

  # limit bbox to PR and some sensible value for max x
  kaki.limitBox(bbox, kaki.box(0, 0, 1024, 131))

  buffer = kaki.Buffer(bbox.x1 - bbox.x0, bbox.y1 - bbox.y0, optOversample, True)
  buffer.setOrigin(bbox.x0, bbox.y0)

  kaki.drawMesh(buffer, mesh)

  buffer.fog(fog0, fog1)

  newNotes = kaki.render(buffer, bbox.x0, bbox.y0)

  for n in newNotes:
    n.group = 1
    flp.score.addNote(n)