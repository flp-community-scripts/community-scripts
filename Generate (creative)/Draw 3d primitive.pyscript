"""flp
Title: {}
Author: BinaryBorn
Category: {}
Version: 1.0
License: ISC

Description: 
{}

Changelog:
v1.0 (2024-02-19)
  - initial version
"""

import flpianoroll as flp
import kaki
import math

# don't render back faces (pure optimisation)
kaki.config.cull_backface = False

shapes = ['Cube', 'Prism', 'Pyramid', 'Pyramid frustum', 'Sphere', 'Cylinder', 'Cone', 'Cone frustum', 'Torus']

def createCube(pheno: kaki.phenotype) -> kaki.mesh:
  verts: list[kaki.vec4] = []
  tris: list[kaki.tri] = []
  for i in range(6):
    vs = []
    ts = []

    vs.extend([
      kaki.vec4(0.5, 0.5, 0.5),
      kaki.vec4(-0.5, 0.5, 0.5),
      kaki.vec4(-0.5, -0.5, 0.5),
      kaki.vec4(0.5, -0.5, 0.5)
    ])
    tr = kaki.identity4()
    if i < 4:
      tr = kaki.rotateX(tr, i * math.pi / 2)
    elif i == 4:
      tr = kaki.rotateY(tr, -math.pi / 2)
    elif i == 5:
      tr = kaki.rotateY(tr, math.pi / 2)
    kaki.transformPoints(vs, tr)

    ts.extend([
      [0, 1, 2],
      [0, 2, 3],
    ])

    i0 = len(verts)
    ts = [[i+i0 for i in t] for t in ts]

    verts.extend(vs)
    tris.extend(ts)

  phenos = [kaki.copyPhenotype(pheno)] * len(verts)
  
  return kaki.mesh(verts, phenos, tris)

def createPrism(pheno: kaki.phenotype, sides: int, rtop: float = 1.0) -> kaki.mesh:
  if sides < 3: sides = 3
  if sides > 24: sides = 24
  if rtop < 0: rtop = 0

  verts: list[kaki.vec4] = []
  tris: list[kaki.tri] = []

  for n in range(sides):
    # helper coordinates
    a0 = n * 2 * math.pi / sides
    a1 = (n + 1) * 2 * math.pi / sides
    v0 = kaki.vec4(math.cos(a1) * 0.5, 0, math.sin(a1) * 0.5)
    v1 = kaki.vec4(math.cos(a0) * 0.5, 0, math.sin(a0) * 0.5)
    v2 = kaki.vec4(math.cos(a0) * 0.5 * rtop, 0, math.sin(a0) * 0.5 * rtop)
    v3 = kaki.vec4(math.cos(a1) * 0.5 * rtop, 0, math.sin(a1) * 0.5 * rtop)

    vs = []
    ts = []
    vs.extend([
      kaki.vec4(v0.x, -0.5, v0.z),  # mantle
      kaki.vec4(v1.x, -0.5, v1.z),
      kaki.vec4(v2.x, 0.5, v2.z),
      kaki.vec4(0, -0.5, 0),        # bottom face
      kaki.vec4(v0.x, -0.5, v0.z),
      kaki.vec4(v1.x, -0.5, v1.z),
    ])
    ts.extend([
      [0, 1, 2],    # mantle
      [3, 4, 5],    # bottom face
    ])
    if rtop > 0:
      vs.extend([
        kaki.vec4(v3.x, 0.5, v3.z),   # additional mantle vertex
        kaki.vec4(0, 0.5, 0),         # top face
        kaki.vec4(v2.x, 0.5, v2.z),
        kaki.vec4(v3.x, 0.5, v3.z),
      ])
      ts.extend([
        [0, 2, 6],  # additional mantle triangle
        [7, 9, 8],  # top face
      ])

    i0 = len(verts)
    ts = [[i+i0 for i in t] for t in ts]
    
    verts.extend(vs)
    tris.extend(ts)
  
  phenos = [kaki.copyPhenotype(pheno)] * len(verts)

  return kaki.mesh(verts, phenos, tris)

def createSphere(pheno: kaki.phenotype, sides: int) -> kaki.mesh:
  verts: list[kaki.vec4] = []
  tris: list[kaki.tri] = []

  discs = int(max(sides / 2, 3))

  i0 = 2            # offset for mantle vertices
  Ips = discs - 1   # vertices per slice

  # caps
  verts.append(kaki.vec4(0, 0.5, 0))
  verts.append(kaki.vec4(0, -0.5, 0))

  # mantle
  for n in range(sides):
    # helper coordinates
    a0 = n * 2 * math.pi / sides
    tr = kaki.identity4()
    tr = kaki.rotateY(tr, -a0)

    in0 = i0 + n * Ips
    in1 = i0 + ((n + 1) % sides) * Ips 

    vs = []
    ts = []
    for m in range(1, discs):
      b = math.pi / 2 - m * math.pi / discs
      v = kaki.vec4(math.cos(b) * 0.5, math.sin(b) * 0.5, 0)
      v = kaki.transform(v, tr)
      vs.append(v)
      if m < (discs - 1):
        ts.extend([
          [in0+m-1, in1+m-1, in0+m],    # mantle
          [in0+m, in1+m-1, in1+m],
        ])
    ts.extend([
      [0, in1, in0],    # cap
      [1, in0+discs-2, in1+discs-2]
    ])
    
    verts.extend(vs)
    tris.extend(ts)

  phenos = [kaki.copyPhenotype(pheno)] * len(verts)
  
  return kaki.mesh(verts, phenos, tris)

def createCylinder(pheno: kaki.phenotype, sides: int, rtop: float = 1.0) -> kaki.mesh:
  if sides < 3: sides = 3
  if sides > 24: sides = 24
  if rtop < 0: rtop = 0

  verts: list[kaki.vec4] = []
  tris: list[kaki.tri] = []

  i0 = 1      # offset for mantle vertices
  Ips = 3     # vertices per slice

  # caps
  verts.append(kaki.vec4(0, -0.5, 0))
  if rtop > 0:
    verts.append(kaki.vec4(0, 0.5, 0))
    i0 = 2
    Ips = 4

  # mantle
  for n in range(sides):
    # helper coordinates
    a0 = n * 2 * math.pi / sides
    v0 = kaki.vec4(math.cos(a0) * 0.5, -0.5, math.sin(a0) * 0.5)
    v1 = kaki.vec4(math.cos(a0) * 0.5 * rtop, 0.5, math.sin(a0) * 0.5 * rtop)

    in0 = i0 + n * Ips
    in1 = i0 + ((n + 1) % sides) * Ips

    vs = []
    ts = []
    vs.extend([
      kaki.copyVec(v0),       # mantle
      kaki.copyVec(v1),
      kaki.copyVec(v0),       # cap
    ])
    ts.extend([
      [in0, in0+1, in1],      # mantle
      [0, in0+2, in1+2],      # bottom cap
    ])
    if rtop > 0:
      vs.extend([
        kaki.copyVec(v1),     # cap
      ])
      ts.extend([
        [in0+1, in1+1, in1],  # additional mantle triangle
        [1, in1+3, in0+3],    # top cap
      ])
    
    verts.extend(vs)
    tris.extend(ts)
  
  phenos = [kaki.copyPhenotype(pheno)] * len(verts)

  return kaki.mesh(verts, phenos, tris)

def createTorus(pheno: kaki.phenotype, sides: int, ratio: float = 1.0) -> kaki.mesh:
  if sides < 3: sides = 3
  if sides > 24: sides = 24

  verts: list[kaki.vec4] = []
  tris: list[kaki.tri] = []

  Ips = sides     # vertices per slice
  for n in range(sides):
    # helper coordinates
    a0 = n * 2 * math.pi / sides
    tr = kaki.identity4()
    tr = kaki.translate(tr, 0.5, 0, 0)
    tr = kaki.rotateY(tr, -a0)

    in0 = n * Ips
    in1 = ((n + 1) % sides) * Ips 

    vs = []
    ts = []
    for m in range(sides):
      b = m * 2 * math.pi / sides
      v = kaki.vec4(math.cos(b) * 0.5 * ratio, math.sin(b) * 0.5 * ratio, 0)
      v = kaki.transform(v, tr)
      vs.append(v)
      im0 = m
      im1 = (m + 1) % sides
      ts.extend([
        [in0+im0, in0+im1, in1+im0],
        [in0+im1, in1+im1, in1+im0],
      ])

    verts.extend(vs)
    tris.extend(ts)
  
  phenos = [kaki.copyPhenotype(pheno)] * len(verts)

  return kaki.mesh(verts, phenos, tris)

def createDialog():
  form = flp.ScriptDialog("Draw 3D primitive","-"
  + "\r\n--"
  + "\r\n\r\nv1.0 (2024-mm-dd), BinaryBorn")
  form.AddInputCombo('Shape', shapes, 0)
  form.AddInputKnobInt('Sides', 3, 3, 24)
  form.AddInputKnob('Ratio', 1, 0, 1)
  form.AddInputKnobInt('Center x', 16, 0, 128)
  form.AddInputKnobInt('Center y', 60, 0, 131)
  form.AddInputKnobInt('Center z', 0, -128, 0)
  form.AddInputKnob('Scale x', 16, 0, 128)
  form.AddInputKnob('Scale y', 16, 0, 128)
  form.AddInputKnob('Scale z', 16, 0, 128)
  form.AddInputKnob('Rotate x', 0, -math.pi, math.pi)
  form.AddInputKnob('Rotate y', 0, -math.pi, math.pi)
  form.AddInputKnob('Rotate z', 0, -math.pi, math.pi)
  form.AddInputCombo('Rotation order', ['zyx', 'xyz'], 0)
  form.AddInputKnob('Pinch', 0, 0, 0.02)
  form.AddInputText('Material', 'velocity: 0.5; pan: 0.0; color: 0')
  form.AddInputText('Light', 'velocity: 1; pan: 0.0; color: 8')
  form.AddInputCombo('Oversample', ['--', '4x MSAA', '16x MSAA'], 0)
  form.AddInputKnob('Light azimuth', 0, -math.pi, math.pi)
  form.AddInputKnob('Light elevation', 0, 0, math.pi / 2)
  form.AddInputKnob('Fog near', 0, -128, 128)
  form.AddInputKnob('Fog far', -128, -128, 128)

  return form

def apply(form: flp.ScriptDialog):
  optShape = form.GetInputValue('Shape')
  sides = form.GetInputValue('Sides')
  ratio = form.GetInputValue('Ratio')
  cx = form.GetInputValue('Center x')
  cy = form.GetInputValue('Center y')
  cz = form.GetInputValue('Center z')
  sx = form.GetInputValue('Scale x')
  sy = form.GetInputValue('Scale y')
  sz = form.GetInputValue('Scale z')
  rotx = form.GetInputValue('Rotate x')
  roty = form.GetInputValue('Rotate y')
  rotz = form.GetInputValue('Rotate z')
  rotOrder = form.GetInputValue('Rotation order')
  pinch = form.GetInputValue('Pinch')
  styleMat = form.GetInputValue('Material')
  styleLight = form.GetInputValue('Light')
  optOversample = form.GetInputValue('Oversample')
  lightAzi = form.GetInputValue('Light azimuth')
  lightEle = form.GetInputValue('Light elevation')
  fog0 = form.GetInputValue('Fog near')
  fog1 = form.GetInputValue('Fog far')

  shape = shapes[optShape]
  phenoMat = kaki.parsePhenotypeFromStyle(styleMat)
  phenoLight = kaki.parsePhenotypeFromStyle(styleLight)

  mesh: kaki.mesh
  if shape == 'Cube':
    mesh = createCube(phenoMat)
  elif shape == 'Prism':
    mesh = createPrism(phenoMat, sides)
  elif shape == 'Pyramid':
    mesh = createPrism(phenoMat, sides, 0)
  elif shape == 'Pyramid frustum':
    mesh = createPrism(phenoMat, sides, ratio)
  elif shape == 'Sphere':
    mesh = createSphere(phenoMat, 24)
  elif shape == 'Cylinder':
    mesh = createCylinder(phenoMat, 24)
  elif shape == 'Cone':
    mesh = createCylinder(phenoMat, 24, 0)
  elif shape == 'Cone frustum':
    mesh = createCylinder(phenoMat, 24, ratio)
  elif shape == 'Torus':
    mesh = createTorus(phenoMat, 24, ratio)
  else:
    mesh = kaki.mesh([], [], [])

  # first: transform up to including rotation (because of lighting)
  transform3d = kaki.identity4()
  transform3d = kaki.scale(transform3d, sx, sy, sz)
  if rotOrder == 0:
    transform3d = kaki.rotateZ(transform3d, rotz)
    transform3d = kaki.rotateY(transform3d, roty)
    transform3d = kaki.rotateX(transform3d, rotx)
  else:
    transform3d = kaki.rotateX(transform3d, rotx)
    transform3d = kaki.rotateY(transform3d, roty)
    transform3d = kaki.rotateZ(transform3d, rotz)
  kaki.transformMesh(mesh, transform3d)

  # second: lighting (before pinching)
  kaki.updateNormalsMesh(mesh)
  light = kaki.vec4(1, 0, 0)
  trLight = kaki.identity4()
  trLight = kaki.rotateY(trLight, lightEle)
  trLight = kaki.rotateZ(trLight, lightAzi)
  light = kaki.transform(light, trLight)
  kaki.lightMesh(mesh, light, phenoLight)

  # third: move into shot, pinch, move shot
  transform3d = kaki.identity4()
  transform3d = kaki.translate(transform3d, 0, 0, cz)
  transform3d = kaki.perspectiveTransform(transform3d, pinch)
  transform3d = kaki.translate(transform3d, cx, cy, 0)
  kaki.transformMesh(mesh, transform3d)
  kaki.perspectiveDivideMesh(mesh)

  bbox = kaki.getMeshBoundingBox(mesh, True)
  if bbox is None: return

  # limit bbox to PR and some sensible value for max x
  kaki.limitBox(bbox, kaki.box(0, 0, 1024, 131))

  buffer = kaki.Buffer(bbox.x1 - bbox.x0, bbox.y1 - bbox.y0, optOversample, True)
  buffer.setOrigin(bbox.x0, bbox.y0)

  kaki.drawMesh(buffer, mesh)

  buffer.fog(fog0, fog1)

  newNotes = kaki.render(buffer, bbox.x0, bbox.y0)

  for n in newNotes:
    n.group = 1
    flp.score.addNote(n)