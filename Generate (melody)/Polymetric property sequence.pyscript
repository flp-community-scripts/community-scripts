"""flp
Title: Polymetric property sequence
Author: BinaryBorn
Category: Generate (melody)
Version: 1.1
License: ISC

Description: 
Create a complex sequence from sequencing note properties individually.

Changelog:
v1.0 (2024-08-14)
  - initial version

v1.1 (2024-08-16)
  - fixed timing errors when using rhythms relying on sub-tick precision
  - added markers option
  - added limit to one option
  - added note length sequence
"""

import flpianoroll as flp
import re
from typing import Callable

PPQ = flp.score.PPQ
PP16TH = PPQ // 4
PPBAR = PPQ * 4

DEFAULT = flp.Note()
DEFAULT.length = PP16TH
CURRENT = flp.score.getDefaultNoteProperties()

TIME_PRECISION = 100 # internal tick-subdivision
PPQ_PRECISE = PPQ * TIME_PRECISION
PP16TH_PRECISE = PP16TH * TIME_PRECISION

def parseNoteValue(value: str) -> float:
  """Parses a note value text.

  Args:
      value (str): Note value text, either a MIDI note number or a pitch (e.g. C4)

  Returns:
      float: MIDI note number.
  """
  if value.isnumeric():
    return float(value)
  # if value is stringy, it has to be a note
  match = re.match(r"(?P<note>[A-Ga-g]#?)(?P<octave>\d)?", value)
  note = str(match.group('note'))
  noteNr = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'].index(note.upper())
  octave = int(match.group('octave') or 5)
  return 12 * octave + noteNr

# property traits
class Traits:
  def __init__(self, valuePattern = '-?\d+(\.\d+)?', valueParser: Callable[[str], float] = lambda t: float(t), unitPattern = '', units: dict[str, float] = [], defaultUnit: str|None = None, optionsPattern = '', errorValue = 0.0) -> None:
    self.valuePattern = valuePattern
    "Regex for value"
    self.valueParser = valueParser
    "Function to parse value"
    self.unitPattern = unitPattern
    "Regex for units"
    self.units = units
    "Dictionary for units and their respective values"
    self.defaultUnit = defaultUnit
    "Default unit"
    self.optionsPattern = optionsPattern
    "Regex for options"
    self.errorValue = errorValue
    "Fallback value to use on errors"

TRAITS_RHYTHM = Traits(
  unitPattern='[DCsbhqtdTfF]',
  units={
    'D': DEFAULT.length,
    'C': CURRENT.length,
    's': PP16TH,
    'b': PPQ,
    'h': PP16TH // 2,
    'q': PP16TH // 4,
    't': PP16TH // 3,
    'd': PP16TH * 1.5,
    'T': 1,
    'f': 1, # re-interpreted in apply()
    'F': 1, # re-interpreted in apply()
  },
  defaultUnit='s',
  optionsPattern="[-_,.eE!]*",
  # options are interpreted in apply()
  errorValue=PP16TH,
)

TRAITS_PITCH = Traits(
  valuePattern='(\d+|([A-Ga-g]#?\d*))',
  valueParser=parseNoteValue,
  errorValue=60,
)

TRAITS_LENGTH = Traits(
  unitPattern='[DCsbhqtdTfF*]',
  units={
    'D': DEFAULT.length,
    'C': CURRENT.length,
    's': PP16TH,
    'b': PPQ,
    'h': PP16TH // 2,
    'q': PP16TH // 4,
    't': PP16TH // 3,
    'd': PP16TH * 1.5,
    'T': 1,
    'f': 1, # re-interpreted in apply()
    'F': 1, # re-interpreted in apply()
    '*': 1, # re-interpreted in apply()
  },
  defaultUnit='*',
  errorValue=1,
)

TRAITS_PAN = Traits(
  unitPattern='[DClr]',
  units={
    'D': DEFAULT.pan * 2 - 1,
    'C': CURRENT.pan * 2 - 1,
    'l': -1,
    'r': 1,
  },
  defaultUnit='r',
  errorValue=0,
)

TRAITS_VELOCITY = Traits(
  unitPattern='[DC]',
  units={
    'D': DEFAULT.velocity,
    'C': CURRENT.velocity,
  },
  errorValue=100/128
)

TRAITS_RELEASE = Traits(
  unitPattern='[DC]',
  units={
    'D': DEFAULT.release,
    'C': CURRENT.release,
  },
  errorValue=0.5
)

TRAITS_FCUT = Traits(
  unitPattern='[DC]',
  units={
    'D': DEFAULT.fcut * 2 - 1,
    'C': CURRENT.fcut * 2 - 1,
  },
  errorValue=0
)

TRAITS_FRES = Traits(
  unitPattern='[DC]',
  units={
    'D': DEFAULT.fres * 2 - 1,
    'C': CURRENT.fres * 2 - 1,
  },
  errorValue=0
)

TRAITS_PITCHOFS = Traits(
  unitPattern='[DC]',
  units={
    'D': DEFAULT.pitchofs * 10,
    'C': CURRENT.pitchofs * 10,
  },
  errorValue=0
)

TRAITS_REPEATS = Traits(
  unitPattern='[DC]',
  units={
    'D': DEFAULT.repeats,
    'C': CURRENT.repeats,
  },
  errorValue=0
)

TRAITS_COLOR = Traits(
  unitPattern='[DC]',
  units={
    'D': DEFAULT.color,
    'C': CURRENT.color,
  },
  errorValue=0
)

TRAITS_PORTA = Traits(
  unitPattern='[DC]',
  units={
    'D': int(DEFAULT.porta),
    'C': int(CURRENT.porta),
  },
  errorValue=0
)

class Step:
  def __init__(self, value: float, unit: str|None = None, options: str|None = None, error: bool = False) -> None:
    self.value = value
    "Step value"
    self.unit = unit
    "Step unit"
    self.options = options or ''
    "Step options"
    self.error = error
    "True if step is erroneous"

def stepFromDescription(valueStr: str|None, unit: str|None, options: str|None, traits: Traits) -> Step:
  """Creates a Step from descriptor texts.
  """
  if unit is None:
    unit = traits.defaultUnit

  if valueStr is None:
    value = 1
  else:
    value = traits.valueParser(valueStr)

  if unit:
    value = value * traits.units[unit]

  step = Step(
    value=value,
    unit=unit,
    options=options
  )
  return step

callstack: list[str] = []
def stepFromError(error: str, traits: Traits) -> Step:
  """Creates a Step indicating an error. Logs the error."""
  flp.Utils.log('')
  flp.Utils.log(error)
  for cs in callstack:
    flp.Utils.log(f'\t{cs}')
  return Step(
    value=traits.errorValue,
    error=True,
  )

def sequence(seq: str, traits: Traits) -> list[Step]:
  """Sequences (the verb) a sequence (the noun) from its stringyfied form to a list of Steps
  
  Args:
      seq (str): Text to sequence.
      traits (Traits): Traits to apply.
  """

  global callstack

  initialSeq = seq

  def expandRepetitions(match: re.Match) -> str:
    nonlocal expanded
    expanded = True
    reps = int(str(match.group('repetitions')).replace('x', ''))
    pattern = str(match.group('pattern'))
    return " ".join([pattern] * reps)

  # before sequencing: expand repetitions of form 3x(...)
  # (in a loop to allow nested repetitions)
  while True:
    expanded = False
    # disallow ( in pattern to catch innermost occurences
    seq = re.sub(r'\b(?P<repetitions>\d+x)\((?P<pattern>[^\(\)]*)\)', expandRepetitions, seq)
    if not expanded: break

  # expand repetitions of form 3x...
  # disallow spaces in pattern to limit to one expression
  seq = re.sub(r'\b(?P<repetitions>\d+x)(?P<pattern>[^\s]*)', expandRepetitions, seq)

  exps = seq.split(' ')
  # remove other leading/trailing whitespace
  exps = list([exp.strip() for exp in exps])
  # remove empty entries
  exps = filter(lambda exp: exp != '', exps)

  # prepare pattern for expression

  pval = f'(?P<value>{traits.valuePattern})?'
  punit = f'(?P<unit>{traits.unitPattern})?'
  popts = f'(?P<options>{traits.optionsPattern})?'

  # every expression must contain exactly the given patterns, hence the ^$ fence
  pattern = re.compile(f'^{pval}{punit}{popts}$')

  callstack = [
    f'In sequence (expanded): {seq}',
    f'In sequence: {initialSeq}',
  ]

  # parse every expression in sequence
  steps: list[Step] = []
  for exp in exps:
    match = pattern.match(exp)
    if match is None:
      steps.append(stepFromError(f'Error in expression: {exp}', traits))
    else:
      step = stepFromDescription(
        match.group('value'),
        match.group('unit'),
        match.group('options'),
        traits,
      )
      steps.append(step)

  return steps

def createDialog():
  form = flp.ScriptDialog("Polymetric property sequence","Create a complex sequence from sequencing note properties individually."
  + '\r\n'
  + '\r\nThe basic grammar is a space-separated sequence of expressions.'
  + '\r\n\te.g. 60 80 60'
  + '\r\n'
  + '\r\nThe syntax for expressions is:'
  + '\r\n\texpression ::= value unit? options?'
  + '\r\n\te.g. 0.5s-'
  + '\r\n'
  + '\r\nPossible values for value, unit and options depend on the property they\'re used on and are detailed down below.'
  + '\r\n'
  + '\r\n'
  + '\r\nSYNTAX GUIDE:'
  + '\r\n'
  + '\r\nThe syntax for a sequence is a space-separated list of sub-sequences or expressions:'
  + '\r\n\tsequence ::= subSeqOrExpr (" " subSeqOrExpr)*'
  + '\r\n\tsubSeqOrExpr ::= subSequence | expression'
  + '\r\n'
  + '\r\nA sub-sequence is a short notation form for repetitions, either for another nested sequence in brackets or a single expression:'
  + '\r\n\tsubSequence ::='
  + '\r\n\t\t<positive integer> "x" "(" sequence ")" |'
  + '\r\n\t\t<positive integer> "x" expression'
  + '\r\n\te.g. 3x(60 2x80) 70'
  + '\r\n'
  + '\r\n'
  + '\r\nPROPERTIES:'
  + '\r\n'
  + '\r\nRhythm is the most complex one in terms of available units and options:'
  + '\r\n\tvalue_rhythm ::= <number>'
  + '\r\n\tunit_rhythm ::='
  + '\r\n\t\t"s" (*step*) |'
  + '\r\n\t\t"b" (*beat*) |'
  + '\r\n\t\t"h" (*half step*) |'
  + '\r\n\t\t"q" (*quarter step*) |'
  + '\r\n\t\t"t" (*one third of a step*) |'
  + '\r\n\t\t"d" (*dotted step*) |'
  + '\r\n\t\t"T" (*tick*) |'
  + '\r\n\t\t"f" (*free space to nearest full step*) |'
  + '\r\n\t\t"F" (*free space to nearest full beat*) |'
  + '\r\n\t\tunit_defaults'
  + '\r\n\toptions_rhythm ::= ('
  + '\r\n\t\t"-" (*pause*) |'
  + '\r\n\t\t"_" (*pause but increase other sequences\' index*) |'
  + '\r\n\t\t"," (*hold other sequences\' index*) |'
  + '\r\n\t\t"." (*reset other sequences\' index*) |'
  + '\r\n\t\t"e" (*extend to nearest full step*) |'
  + '\r\n\t\t"E" (*extend to nearest full beat*) |'
  + '\r\n\t\t"!" (*cut at the nearest multiple of defined duration*)'
  + '\r\n\t)*'
  + '\r\n'
  + '\r\nOptions can be combined, e.g. 0.7Fe- is a pause (-) extended to the nearest step (e) with base length 70% of the space to the nearest beat (0.7F)'
  + '\r\n'
  + '\r\n'
  + '\r\nFor melody, either a MIDI note number or a pitch can be used as value:'
  + '\r\n\tvalue_melody ::='
  + '\r\n\t\t<whole number 0-131> |'
  + '\r\n\t\t([A-G] "#"? <number 0-10, default 5>)'
  + '\r\n'
  + '\r\n'
  + '\r\nFor length, the same units as for rhythm can be used. Additionally the note length derived from rhythm can be referenced with * (default, can be omitted):'
  + '\r\n\tunit_length ::='
  + '\r\n\t\tunit_rhythm |'
  + '\r\n\t\t"*" (*note length derived from rhythm*)'
  + '\r\n'
  + '\r\n'
  + '\r\nFor pan, left and right (default) can be used as unit:'
  + '\r\n\tvalue_pan ::= <number -1.0 to 1.0>'
  + '\r\n\tunit_pan ::= "l" (*left*) | "r" (*right*) | unit_defaults'
  + '\r\n'
  + '\r\n'
  + '\r\nThe rest of the properties have the following number ranges:'
  + '\r\n\tvalue_velocity ::= <number 0.0 to 1.0>'
  + '\r\n\tvalue_release ::= <number 0.0 to 1.0>'
  + '\r\n\tvalue_modx ::= <number -1.0 to 1.0>'
  + '\r\n\tvalue_mody ::= <number -1.0 to 1.0>'
  + '\r\n\tvalue_finepitch ::= <whole number -1200 to 1200>'
  + '\r\n\tvalue_repeats ::= <whole number 0 to 14>'
  + '\r\n\tvalue_color ::= <whole number 0 to 15>'
  + '\r\n\tvalue_porta ::= <whole number 0 or 1>'
  + '\r\n'
  + '\r\nThey all have access to the default units:'
  + '\r\n\tunit_defaults ::= "D" (*default value*) | "C" (*current value*)'
  + '\r\n'
  + '\r\nValues can be omitted if a unit is given. It will then fall back to 1.'
  + '\r\n'
  + '\r\n'
  + "\r\nv1.1 (2024-08-14), BinaryBorn")
  form.AddInputKnobInt('Duration', 16, 1, 512)
  form.AddInputCombo('Duration unit', ['beats', 'bars', 'iterations'], 0)
  form.AddInputCheckbox('Clear score', True)
  form.AddInputCheckbox('Place markers', True)
  form.AddInputCheckbox('Limit to one', False)
  form.AddInputText('Rhythm', '3xs 0.5s 0.5s-')
  form.AddInputText('Melody', 'C4 C5 C6')
  form.AddInputText('Length', '1')
  form.AddInputText('Pan', '0 0 0.5r 0.5l r l')
  form.AddInputText('Velocity', '4xD 1')
  form.AddInputText('Release', 'D')
  form.AddInputText('Mod X', '0')
  form.AddInputText('Mod Y', '0')
  form.AddInputText('Fine Pitch', '0')
  form.AddInputText('Repeats', '0')
  form.AddInputText('Color', 'C')
  form.AddInputText('Porta', '0')
  
  return form

def apply(form: flp.ScriptDialog):
  global callstack

  duration = int(form.GetInputValue('Duration'))
  durationUnit = int(form.GetInputValue('Duration unit'))
  optClearScore = bool(form.GetInputValue('Clear score'))
  optMarkers = bool(form.GetInputValue('Place markers'))
  optLimit = bool(form.GetInputValue('Limit to one'))

  rtmStr = form.GetInputValue('Rhythm')
  melStr = form.GetInputValue('Melody')
  lenStr = form.GetInputValue('Length')
  panStr = form.GetInputValue('Pan')
  velStr = form.GetInputValue('Velocity')
  relStr = form.GetInputValue('Release')
  cutStr = form.GetInputValue('Mod X')
  resStr = form.GetInputValue('Mod Y')
  pofStr = form.GetInputValue('Fine Pitch')
  repStr = form.GetInputValue('Repeats')
  colStr = form.GetInputValue('Color')
  porStr = form.GetInputValue('Porta')

  rtmSeq = sequence(rtmStr, TRAITS_RHYTHM)
  melSeq = sequence(melStr, TRAITS_PITCH)
  lenSeq = sequence(lenStr, TRAITS_LENGTH)
  panSeq = sequence(panStr, TRAITS_PAN)
  velSeq = sequence(velStr, TRAITS_VELOCITY)
  relSeq = sequence(relStr, TRAITS_RELEASE)
  cutSeq = sequence(cutStr, TRAITS_FCUT)
  resSeq = sequence(resStr, TRAITS_FRES)
  pofSeq = sequence(pofStr, TRAITS_PITCHOFS)
  repSeq = sequence(repStr, TRAITS_REPEATS)
  colSeq = sequence(colStr, TRAITS_COLOR)
  porSeq = sequence(porStr, TRAITS_PORTA)

  callstack = []

  # assert minimum sequence lengths
  if len(rtmSeq) == 0: rtmSeq = [stepFromError('Empty sequence', TRAITS_RHYTHM)]
  if len(melSeq) == 0: melSeq = [stepFromError('Empty sequence', TRAITS_PITCH)]
  if len(lenSeq) == 0: lenSeq = [stepFromError('Empty sequence', TRAITS_LENGTH)]
  if len(panSeq) == 0: panSeq = [stepFromError('Empty sequence', TRAITS_PAN)]
  if len(velSeq) == 0: velSeq = [stepFromError('Empty sequence', TRAITS_VELOCITY)]
  if len(relSeq) == 0: relSeq = [stepFromError('Empty sequence', TRAITS_RELEASE)]
  if len(cutSeq) == 0: cutSeq = [stepFromError('Empty sequence', TRAITS_FCUT)]
  if len(resSeq) == 0: resSeq = [stepFromError('Empty sequence', TRAITS_FRES)]
  if len(pofSeq) == 0: pofSeq = [stepFromError('Empty sequence', TRAITS_PITCHOFS)]
  if len(repSeq) == 0: repSeq = [stepFromError('Empty sequence', TRAITS_REPEATS)]
  if len(colSeq) == 0: colSeq = [stepFromError('Empty sequence', TRAITS_COLOR)]
  if len(porSeq) == 0: porSeq = [stepFromError('Empty sequence', TRAITS_PORTA)]

  # sequences have been prepared - turn into one long sequence
  
  notes: list[flp.Note] = []
  markers: list[flp.Marker] = []
  t_precise = 0 # high-precision time
  i = -1 # rhythm sequence index
  j = 0 # other sequences' index
  revs = 0

  # convert duration to its actual meaning
  if durationUnit == 0:
    duration *= PPQ
  elif durationUnit == 1:
    duration *= PPBAR

  while True:
    i += 1

    # this step's starting time
    t0_precise = t_precise
    t0 = round(t0_precise / TIME_PRECISION)

    # index and t0 up-to-date, check ending condition
    if durationUnit == 2:
      if i >= duration: break
    else:
      if t0 >= duration: break

    rtmStep = rtmSeq[i % len(rtmSeq)]

    # sync index j according to step options
    if '.' in rtmStep.options:
      j = 0
    elif '-' in rtmStep.options or ',' in rtmStep.options:
      pass
    elif i > 0:
      j += 1

    # new start?
    if (
      i % len(rtmSeq) == 0 and
      j % len(melSeq) == 0 and
      j % len(lenSeq) == 0 and
      j % len(panSeq) == 0 and
      j % len(velSeq) == 0 and
      j % len(relSeq) == 0 and
      j % len(cutSeq) == 0 and
      j % len(resSeq) == 0 and
      j % len(pofSeq) == 0 and
      j % len(repSeq) == 0 and
      j % len(colSeq) == 0 and
      j % len(porSeq) == 0
    ):
      revs += 1
      if optMarkers:
        marker = flp.Marker()
        markers.append(marker)
        marker.time = t0
        marker.name = f'Revolution {revs}'
      if optLimit and revs == 2:
        if marker:
          marker.name = 'End'
          marker.mode = 6
        break

    melStep = melSeq[j % len(melSeq)]
    lenStep = lenSeq[j % len(lenSeq)]
    panStep = panSeq[j % len(panSeq)]
    velStep = velSeq[j % len(velSeq)]
    relStep = relSeq[j % len(relSeq)]
    cutStep = cutSeq[j % len(cutSeq)]
    resStep = resSeq[j % len(resSeq)]
    pofStep = pofSeq[j % len(pofSeq)]
    repStep = repSeq[j % len(repSeq)]
    colStep = colSeq[j % len(colSeq)]
    porStep = porSeq[j % len(porSeq)]

    # derive delta time from precise timing to preserve jitter
    t1_precise = round(t0_precise + rtmStep.value * TIME_PRECISION)
    dt_precise = t1_precise - t0_precise
    # apply space filling units
    if rtmStep.unit == 'f':
      space = PP16TH_PRECISE - (t0_precise % PP16TH_PRECISE)
      dt_precise = round(rtmStep.value * space)
    elif rtmStep.unit == 'F':
      space = PPQ_PRECISE - (t0_precise % PPQ_PRECISE)
      dt_precise = round(rtmStep.value * space)
    # apply extending options
    if 'e' in rtmStep.options:
      dt_precise += (PP16TH_PRECISE - (t1_precise % PP16TH_PRECISE)) % PP16TH_PRECISE # second modulo prevents rounding up whole step
    elif 'E' in rtmStep.options:
      dt_precise += (PPQ - (t1_precise % PPQ)) % PPQ # second modulo prevents rounding up whole beat
    elif '!' in rtmStep.options:
      dt_precise = (dt_precise - (t0_precise % dt_precise))

    # delta time shall never be less than one tick
    if dt_precise < TIME_PRECISION: dt_precise = TIME_PRECISION
    t1_precise = t0_precise + dt_precise
    # next step's starting time is this step's end time
    t_precise = t1_precise

    # calculate length in tick space
    t1 = round(t1_precise / TIME_PRECISION)
    dt = t1 - t0 
    # init note length with absolute value
    length = lenStep.value
    # apply dynamic units
    if lenStep.unit == 'f':
      space = PP16TH - (t0 % PP16TH)
      length *= space
      if length < 1: length = 1
    elif lenStep.unit == 'F':
      space = PPQ - (t0 % PPQ)
      length *= space
      if length < 1: length = 1
    elif lenStep.unit == '*':
      length *= dt
      if length < 1: length = 1

    # pause? skip placing a note
    if '-' in rtmStep.options or '_' in rtmStep.options: continue

    note = flp.Note()
    note.time = t0
    note.length = round(length)
    note.number = round(melStep.value)
    note.pan = panStep.value * 0.5 + 0.5
    note.velocity = velStep.value
    note.release = relStep.value
    note.fcut = cutStep.value * 0.5 + 0.5
    note.fres = resStep.value * 0.5 + 0.5
    note.pitchofs = round(pofStep.value / 10)
    note.repeats = round(repStep.value)
    note.color = round(colStep.value)
    note.porta = bool(round(porStep.value))

    # select erroneous notes as a hint
    note.selected = (
      rtmStep.error or
      melStep.error or
      lenStep.error or
      panStep.error or
      velStep.error or
      relStep.error or
      cutStep.error or
      resStep.error or
      pofStep.error or
      repStep.error or
      colStep.error or
      porStep.error
    )
    notes.append(note)
  
  if optClearScore:
    flp.score.clearNotes()
    flp.score.clearMarkers()

  for n in notes:
    flp.score.addNote(n)

  for m in markers:
    flp.score.addMarker(m)
